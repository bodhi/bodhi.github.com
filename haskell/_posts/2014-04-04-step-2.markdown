---
title: Step 2…
layout: default
---

In the [beginning]({% post_url 2014-04-01-begin %}), <del>there was
light</del>, we defined a domain for ranking a person's ability to
solve Rubik's cubes, and implemented a "safe" age type:

{% highlight haskell %}
module Age (Age(),
            ageFromNum)
where

data Age = Age Int | Young | Old deriving (Show) 

ageFromNum :: Int -> Maybe Age
ageFromNum n | n < 0 = Nothing
             | n < 18 = Just Young
             | n > 80 = Just Old
             | otherwise = Just (Age n)
{% endhighlight %}

Lets continue on and implement the rest:

* Speed of solving a 3x3 cube

* Inhabited hemisphere (yes, yes, contrived, yes)

### In record time!

A person's record time, lets just store it in seconds, and we don't
accept any negative values...

{% highlight haskell %}
module SolutionRecord (SolutionRecord(),
            solutionRecordFromInt)
where

data SolutionRecord = SolutionRecord Int deriving (Show) 

solutionRecordFromInt :: Int -> Maybe SolutionRecord
solutionRecordFromInt n | n < 0 = Nothing
                        | otherwise = Just (SolutionRecord n)
{% endhighlight %}

It's basically just a copy-paste from `Age`, but we'll ignore this for
now.

<aside markdown="1">
Actually, reading through [Typeclasses
101](http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101)
I noticed the `Bounded` typeclass, which led to a short hop over to
[this Stack Overflow
question](http://stackoverflow.com/questions/4557394/how-do-you-use-the-bounded-typeclass-in-haskell-to-define-a-type-with-a-floating)
describing how to extract this kind of thing into a bounded typeclass. Needs more research.

</aside>

### Place of domicile?

Is either northern or southern hemisphere:

{% highlight haskell %}
module Location (Location)
       where

data Location = North | South deriving Show
{% endhighlight %}

Wait, what is this `data` really? Back to [Learn You a
Haskell](http://learnyouahaskell.com/making-our-own-types-and-typeclasses):

> `data` means that we're defining a new data type. The part before
  the `=` denotes the type, which is `Bool`. The parts after the `=`
  are value constructors.

## Putting it all together

Ok, now we have our base types, lets put them together into a
container type:

{% highlight haskell %}
module CubeSolver (CubeSolver)
       where

import Age
import SolutionRecord
import Location

data CubeSolver = CubeSolver { age :: Age
                             , recordTime :: SolutionRecord
                             , location:: Location } deriving Show
{% endhighlight %}

<aside>
So it turns out that GHCI looks for modules in files of the same name, so `SolutionRecord` will be assumed to be in a file called `SolutionRecord.hs`.
</aside>

Ok, in GCHI:

    bodhi$ ghci
    GHCi, version 7.4.2: http://www.haskell.org/ghc/  :? for help
    ...
    Prelude> :load CubeSolver
    [1 of 4] Compiling Location         ( Location.hs, interpreted )
    [2 of 4] Compiling SolutionRecord   ( SolutionRecord.hs, interpreted )
    [3 of 4] Compiling Age              ( Age.hs, interpreted )
    [4 of 4] Compiling CubeSolver       ( CubeSolver.hs, interpreted )
    Ok, modules loaded: CubeSolver, Age, SolutionRecord, Location.
    *CubeSolver> CubeSolver (ageFromNum 30) solutionRecordFromInt(15) South

    <interactive>:3:53: Not in scope: data constructor `South'

Er, what? Oh, seems like `Location` was defined as a, er, *Smart Constructor*:

{% highlight haskell %}
module Location (Location)
-- ...
{% endhighlight %}

Changning the exports from `(Location)` to `(Location(..))` does the trick:

    Prelude> :load CubeSolver
    ...
    *CubeSolver> :t South
    South :: Location
    *CubeSolver> South
    South

so,

    *CubeSolver> CubeSolver (ageFromNum 30) (solutionRecordFromInt 15) South

    <interactive>:6:13:
        Couldn't match expected type `Age' with actual type `Maybe Age'
        In the return type of a call of `ageFromNum'
        In the first argument of `CubeSolver', namely `(ageFromNum 30)'
        In the expression:
          CubeSolver (ageFromNum 30) (solutionRecordFromInt 15) South

… oops, right. `ageFromNum 30`'s type is `Maybe Age`, not `Age`:

    *CubeSolver> CubeSolver (Data.Maybe.fromJust (ageFromNum 30)) (Data.Maybe.fromJust (solutionRecordFromInt 15)) South
    CubeSolver {age = Age 30, recordTime = SolutionRecord 15, location = South}

Finally!


## Reduction

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script><script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

Finally we have a `CubeSolver`, now we can contrive together a way to
figure out what a person's *Rubik level* $L$ is, from this
data. Unfortunately (*cough*) our definition uses $L$ as the independent
variable, and is actually a function that predicts the time it takes
$t$ *in minutes* for a person of age $a$ to solve a cube of size $s \times s$:

$$
t = \frac{a}{18 L^2} 4^s + \frac{10}{L^3}
$$

Luckily we can assume that $s$ is a constant, and $a$ is a known input
for a given person. So given $a$, $t$ and $s$, we need to solve the
above equation for $$L$$. *Apparently*, [this can be done
algebraically](http://en.wikipedia.org/wiki/Cubic_function#Roots_of_a_cubic_function)!
But we'll take the long road and explore next time how to solve this
numerically.
