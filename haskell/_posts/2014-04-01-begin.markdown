---
title: Learn me some Haskell
layout: default
---

Ok, I'm going to try to [learn me a Haskell](http://learnyouahaskell.com). Simplest thing to do is to take something from a system at work, and replicate it…

Basic outline of the idea, take some info about a person, and reduce <del>the person</del> the info to a *level* in a given range, depending on the info.

## Setting Up

Lets define the domain as 

> The time it takes you to solve a Rubik's Cube.

First up, lets think about the info we need. The input info is

* Age, let's say 18..80. Rubik's Cubes are obviously adult-themed, thus 18+, and if you are over 80, I'll give even odds that you're dead.

* Your fastest speed at solving a 3x3 cube.

* Whether you … er … live in the northern or southern hemisphere … …

And the output is your *cube level*, indicating your skill, from 1: couldn't solve a 1x1 cube; to 10: those robots [you see on YouTube](https://www.youtube.com/watch?v=_d0LfkIut2M).

## Typing of the Cube

So… age. Counting in years, we could use an `Int`, but that's lame. We have the restriction we defined earlier, so let's try to enforce it. [Digging around on the internet](https://www.google.com/search?q=haskell+range+limited+data+type) gets us to [Stack Overflow](http://stackoverflow.com/questions/10457538/how-to-create-type-which-contains-string-with-limited-length-in-haskell) where the answer seems to be, paraphrasing:

> Use *smart constructors*

… wat.

## Smart Constructors (what, you didn't see this coming?)

No idea? Me neither. First hit: [the Haskell Wiki](http://www.haskell.org/haskellwiki/Smart_constructors).

> Smart constructors are just functions that build values of the required type, but perform some extra checks when the value is constructed

And the examples in the page show various ways to perform the "extra checks". [2.1 Enforcing the constraint statically](http://www.haskell.org/haskellwiki/Smart_constructors#Enforcing_the_constraint_statically) is eye-catching, that sounds pretty much like what I'm trying to do. But the example implementation starts off with 

> Firstly, define some Peano numbers [...]

ohh... I don't really want to define 62 Peano numbers for this. Lets go back to the Stack Overflow version, it just uses `Maybe` for out-of-range numbers. Adapting the code gives us.

{% highlight haskell %}
module Age (Age(),
            ageFromNum)
where

data Age = Age Int | Young | Old deriving (Show) 

ageFromNum :: Int -> Maybe Age
ageFromNum n | n < 0 = Nothing
             | n < 18 = Just Young
             | n > 80 = Just Old
             | otherwise = Just (Age n)
{% endhighlight %}

and that gets us something to play with:

    pasokun:_posts bodhi$ ghci
    GHCi, version 7.4.2: http://www.haskell.org/ghc/  :? for help
    Prelude> :load "age"
    [1 of 1] Compiling Age              ( age.hs, interpreted )
    Ok, modules loaded: Age.
    *Age> Age.ageFromNum (25)
    Just (Age 25)
    *Age> Age.ageFromNum (15)
    Just Young
    *Age> Age.ageFromNum (81)
    Just Old
    *Age> Age.ageFromNum (-1)
    Nothing

Cool. Hmm, bare `Age` constructor seems to be available too, but maybe that's a quirk of GHCI:

    *Age> Age 24
    Age 24

Next up, fleshing out the other data types…